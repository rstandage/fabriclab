#!/usr/bin/env python3
"""
Configuration templates for vJunos-switch
"""

import logging
import subprocess
import re
from typing import Dict, Optional, Tuple
from pathlib import Path

logger = logging.getLogger(__name__)


class JunosConfigTemplate:
    """Manages Junos configuration templates"""
    
    # Base configuration that works for all switches
    BASE_CONFIG = """
# Base configuration for vJunos-switch
# Generated by fabriclab-ng

# Root password: Juniper123!
set system root-authentication encrypted-password $6$.tMirbxZ$/BIGvrB/JknHxubYMtQa38iuaAH4ii5mcD5Atjuh.ZDcmQYNIZRZEKsHNryMs/cGML5PqkWouWwL9TKA/l0cC/

# Disable auto-upgrade
delete chassis auto-image-upgrade

# SSH configuration
set system services ssh protocol-version v2
set system authentication-order password

# Mist user configuration
set system login user mist class super-user
set system login user mist authentication encrypted-password $6$xo.kDu2lveY4mNUv$bgi/yh98Pg48wIihHrs6DCYwOLMh5Pz5xKzkT8Vfl.E1vhQTw163PkrwekAXKomtFfF/u93hVLLVLx66pKS9q.
"""
    
    # Mist adoption configuration (requires device_id and secret from Mist)
    MIST_ADOPTION_CONFIG = """
# Mist adoption configuration
set system login user mist authentication ssh-rsa "{ssh_key}"
set system services outbound-ssh client mist device-id {device_id}
set system services outbound-ssh client mist secret {secret}
set system services outbound-ssh client mist services netconf keep-alive retry 12 timeout 5
set system services outbound-ssh client mist oc-term.mistsys.net port 2200 timeout 60 retry 1000
"""
    
    # Optional: Enable LLDP on all interfaces
    LLDP_CONFIG = """
# LLDP configuration
set protocols lldp interface all
set protocols lldp-med interface all
"""
    
    # Optional: Basic VLAN configuration
    VLAN_CONFIG = """
# VLAN configuration
set vlans default vlan-id 1
set vlans mgmt vlan-id 100
"""
    
    @classmethod
    def generate_base_config(cls, hostname: Optional[str] = None) -> str:
        """
        Generate base configuration
        
        Args:
            hostname: Optional hostname to set
            
        Returns:
            Configuration string
        """
        config = cls.BASE_CONFIG
        
        if hostname:
            config += f"\n# Hostname\nset system host-name {hostname}\n"
        
        return config.strip()
    
    @classmethod
    def generate_adoption_config(
        cls,
        device_id: str,
        secret: str,
        ssh_key: str
    ) -> str:
        """
        Generate Mist adoption configuration
        
        Args:
            device_id: Mist device ID
            secret: Mist secret
            ssh_key: SSH RSA public key from Mist
            
        Returns:
            Configuration string
        """
        return cls.MIST_ADOPTION_CONFIG.format(
            device_id=device_id,
            secret=secret,
            ssh_key=ssh_key
        ).strip()
    
    @classmethod
    def generate_full_config(
        cls,
        hostname: str,
        device_id: str,
        secret: str,
        ssh_key: str,
        enable_lldp: bool = True,
        enable_vlans: bool = False
    ) -> str:
        """
        Generate complete configuration for switch adoption
        
        Args:
            hostname: Switch hostname
            device_id: Mist device ID
            secret: Mist secret
            ssh_key: SSH RSA public key from Mist
            enable_lldp: Whether to enable LLDP
            enable_vlans: Whether to add basic VLAN config
            
        Returns:
            Complete configuration string
        """
        config_parts = [
            cls.generate_base_config(hostname),
            cls.generate_adoption_config(device_id, secret, ssh_key)
        ]
        
        if enable_lldp:
            config_parts.append(cls.LLDP_CONFIG.strip())
        
        if enable_vlans:
            config_parts.append(cls.VLAN_CONFIG.strip())
        
        return "\n\n".join(config_parts)
    
    @classmethod
    def save_config(cls, config: str, output_path: Path) -> bool:
        """
        Save configuration to file
        
        Args:
            config: Configuration string
            output_path: Path to save file
            
        Returns:
            True if successful
        """
        try:
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(config)
            logger.info(f"✓ Configuration saved to {output_path}")
            return True
        except Exception as e:
            logger.error(f"Failed to save config: {e}")
            return False
    
    @classmethod
    def load_config(cls, config_path: Path) -> Optional[str]:
        """
        Load configuration from file
        
        Args:
            config_path: Path to config file
            
        Returns:
            Configuration string or None
        """
        try:
            if not config_path.exists():
                logger.error(f"Config file not found: {config_path}")
                return None
            
            config = config_path.read_text()
            logger.info(f"✓ Configuration loaded from {config_path}")
            return config
        except Exception as e:
            logger.error(f"Failed to load config: {e}")
            return None


class LabConfigManager:
    """Manages lab configuration generation and config disk creation"""
    
    @classmethod
    def load_default_config(cls, template_path: Optional[Path] = None) -> Optional[str]:
        """
        Load the default lab switch configuration template
        
        Args:
            template_path: Path to template config file (defaults to templates/lab_switch_default.config)
            
        Returns:
            Configuration string or None
        """
        if template_path is None:
            # Default to the template in the project
            script_dir = Path(__file__).parent.parent
            template_path = script_dir / "templates" / "lab_switch_default.config"
        
        try:
            if not template_path.exists():
                logger.error(f"Template file not found: {template_path}")
                return None
            
            config = template_path.read_text()
            logger.info(f"✓ Loaded default config template from {template_path}")
            return config
        except Exception as e:
            logger.error(f"Failed to load template: {e}")
            return None
    
    @classmethod
    def customize_config(
        cls,
        config: str,
        hostname: str,
        junos_version: Optional[str] = None
    ) -> str:
        """
        Customize configuration with hostname and optionally Junos version
        
        Args:
            config: Base configuration string
            hostname: New hostname to set
            junos_version: Optional Junos version to set
            
        Returns:
            Customized configuration string
        """
        # Replace hostname
        config = re.sub(
            r'(system\s*\{[^}]*host-name\s+)\S+;',
            rf'\1{hostname};',
            config,
            flags=re.DOTALL
        )
        
        # Replace version if provided
        if junos_version:
            config = re.sub(
                r'^version\s+[^;]+;',
                f'version {junos_version};',
                config,
                flags=re.MULTILINE
            )
        
        logger.info(f"✓ Customized config for hostname: {hostname}")
        if junos_version:
            logger.info(f"  Version set to: {junos_version}")
        
        return config
    
    @classmethod
    def extract_mist_variables(cls, adopt_template_path: Path) -> Optional[Dict[str, str]]:
        """
        Extract Mist variables from adopt-template.txt file
        
        Args:
            adopt_template_path: Path to adopt-template.txt from Mist
            
        Returns:
            Dictionary with mist variables or None
        """
        try:
            if not adopt_template_path.exists():
                logger.error(f"Adopt template not found: {adopt_template_path}")
                return None
            
            content = adopt_template_path.read_text().replace('"', '')
            
            # Extract variables using patterns from Juniper documentation
            patterns = {
                'encrypted_password': r'set system login user mist authentication encrypted-password (\S+)',
                'ssh_rsa': r'set system login user mist authentication ssh-rsa (.+)',
                'secret': r'set system services outbound-ssh client mist secret (\S+)',
                'port_line': r'(set system services outbound-ssh client mist \S+ port \d+)',
                'device_id': r'set system services outbound-ssh client mist device-id (\S+)'
            }
            
            variables = {}
            for key, pattern in patterns.items():
                match = re.search(pattern, content)
                if match:
                    variables[key] = match.group(1)
                else:
                    logger.warning(f"Could not extract {key} from adopt template")
            
            if len(variables) >= 5:
                logger.info("✓ Extracted Mist adoption variables")
                return variables
            else:
                logger.error("Failed to extract all required Mist variables")
                return None
                
        except Exception as e:
            logger.error(f"Failed to extract Mist variables: {e}")
            return None
    
    @classmethod
    def add_mist_adoption(
        cls,
        config: str,
        mist_vars: Dict[str, str]
    ) -> str:
        """
        Add Mist adoption configuration to base config
        
        Args:
            config: Base configuration string
            mist_vars: Dictionary of Mist variables from extract_mist_variables
            
        Returns:
            Configuration with Mist adoption added
        """
        # Check if mist user already exists in config
        if 'user mist' in config:
            logger.info("Mist user already exists in config, will merge adoption settings")
        
        # Build the adoption configuration following Juniper documentation format
        adoption_config = f"""
system {{
    login {{
        user mist {{
            class super-user;
            authentication {{
                encrypted-password "{mist_vars['encrypted_password']}";
                ssh-rsa "{mist_vars['ssh_rsa']}";
            }}
        }}
    }}
    services {{
        outbound-ssh {{
            client mist {{
                device-id "{mist_vars['device_id']}";
                secret "{mist_vars['secret']}";
                keep-alive {{
                    retry 12;
                    timeout 5;
                }}
                services netconf;
                {mist_vars.get('port_line', 'oc-term.mistsys.net')} {{
                    port 2200;
                    retry 1000;
                    timeout 60;
                }}
            }}
        }}
    }}
}}
"""
        
        logger.info("✓ Added Mist adoption configuration")
        return config + "\n" + adoption_config
    
    @classmethod
    def create_config_disk(
        cls,
        config: str,
        vm_name: str,
        output_dir: Optional[Path] = None
    ) -> Tuple[bool, Optional[Path]]:
        """
        Create a configuration disk image using make-config.sh
        
        Note: Despite the .qcow2 extension, this creates a RAW format disk
        with a FAT12 filesystem, following Juniper's specification.
        
        Args:
            config: Configuration string
            vm_name: VM name (used for filenames)
            output_dir: Directory to save files (defaults to ./config)
            
        Returns:
            Tuple of (success, config_disk_path)
        """
        if output_dir is None:
            output_dir = Path(__file__).parent.parent / "config"
        
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Save the juniper.conf file
        config_file = output_dir / f"{vm_name}.conf"
        config_disk = output_dir / f"{vm_name}-config.raw"
        
        try:
            # Write config to file
            config_file.write_text(config)
            logger.info(f"✓ Saved config to {config_file}")
            
            # Find make-config.sh script
            script_dir = Path(__file__).parent.parent
            make_config_script = script_dir / "templates" / "make-config.sh"
            
            if not make_config_script.exists():
                logger.error(f"make-config.sh not found at {make_config_script}")
                return False, None
            
            # Make sure script is executable
            make_config_script.chmod(0o755)
            
            # Run make-config.sh
            logger.info(f"Creating config disk using make-config.sh...")
            result = subprocess.run(
                [str(make_config_script), str(config_file), str(config_disk)],
                capture_output=True,
                text=True,
                cwd=output_dir
            )
            
            if result.returncode == 0:
                logger.info(f"✓ Config disk created: {config_disk}")
                logger.debug(result.stdout)
                return True, config_disk
            else:
                logger.error(f"Failed to create config disk: {result.stderr}")
                return False, None
                
        except Exception as e:
            logger.error(f"Failed to create config disk: {e}")
            return False, None
    
    @classmethod
    def create_lab_config(
        cls,
        vm_name: str,
        junos_version: Optional[str] = None,
        adopt_template: Optional[Path] = None,
        output_dir: Optional[Path] = None
    ) -> Tuple[bool, Optional[Path]]:
        """
        Complete workflow to create a lab configuration disk
        
        Args:
            vm_name: VM hostname
            junos_version: Optional Junos version to set
            adopt_template: Optional path to Mist adopt-template.txt
            output_dir: Directory to save files
            
        Returns:
            Tuple of (success, config_disk_path)
        """
        logger.info(f"\nCreating lab configuration for {vm_name}...")
        
        # Load default config
        config = cls.load_default_config()
        if not config:
            return False, None
        
        # Customize with hostname and version
        config = cls.customize_config(config, vm_name, junos_version)
        
        # Add Mist adoption if template provided
        if adopt_template:
            mist_vars = cls.extract_mist_variables(adopt_template)
            if mist_vars:
                config = cls.add_mist_adoption(config, mist_vars)
            else:
                logger.warning("Continuing without Mist adoption configuration")
        
        # Create config disk
        return cls.create_config_disk(config, vm_name, output_dir)


class FabricTopology:
    """Manages fabric topology configurations"""
    
    # Common fabric topologies
    TOPOLOGIES = {
        "spine-leaf-2x2": {
            "description": "2 Spine, 2 Leaf switches",
            "switches": [
                {"name": "spine-1", "id": 201, "role": "spine"},
                {"name": "spine-2", "id": 202, "role": "spine"},
                {"name": "leaf-1", "id": 211, "role": "leaf"},
                {"name": "leaf-2", "id": 212, "role": "leaf"}
            ],
            "connections": [
                {"from": "spine-1", "to": "leaf-1"},
                {"from": "spine-1", "to": "leaf-2"},
                {"from": "spine-2", "to": "leaf-1"},
                {"from": "spine-2", "to": "leaf-2"}
            ]
        },
        "spine-leaf-2x4": {
            "description": "2 Spine, 4 Leaf switches",
            "switches": [
                {"name": "spine-1", "id": 201, "role": "spine"},
                {"name": "spine-2", "id": 202, "role": "spine"},
                {"name": "leaf-1", "id": 211, "role": "leaf"},
                {"name": "leaf-2", "id": 212, "role": "leaf"},
                {"name": "leaf-3", "id": 213, "role": "leaf"},
                {"name": "leaf-4", "id": 214, "role": "leaf"}
            ],
            "connections": [
                {"from": "spine-1", "to": "leaf-1"},
                {"from": "spine-1", "to": "leaf-2"},
                {"from": "spine-1", "to": "leaf-3"},
                {"from": "spine-1", "to": "leaf-4"},
                {"from": "spine-2", "to": "leaf-1"},
                {"from": "spine-2", "to": "leaf-2"},
                {"from": "spine-2", "to": "leaf-3"},
                {"from": "spine-2", "to": "leaf-4"}
            ]
        },
        "linear": {
            "description": "3 switches in a line",
            "switches": [
                {"name": "core-1", "id": 201, "role": "core"},
                {"name": "dist-1", "id": 202, "role": "distribution"},
                {"name": "access-1", "id": 203, "role": "access"}
            ],
            "connections": [
                {"from": "core-1", "to": "dist-1"},
                {"from": "dist-1", "to": "access-1"}
            ]
        }
    }
    
    @classmethod
    def list_topologies(cls) -> Dict:
        """List all available topologies"""
        return {
            name: topo["description"] 
            for name, topo in cls.TOPOLOGIES.items()
        }
    
    @classmethod
    def get_topology(cls, name: str) -> Optional[Dict]:
        """Get a specific topology configuration"""
        return cls.TOPOLOGIES.get(name)
    
    @classmethod
    def print_topology(cls, name: str):
        """Print topology details"""
        topo = cls.get_topology(name)
        if not topo:
            logger.error(f"Topology '{name}' not found")
            return
        
        print(f"\n{name.upper()} Topology")
        print(f"Description: {topo['description']}")
        print("\nSwitches:")
        for sw in topo["switches"]:
            print(f"  - {sw['name']} (ID: {sw['id']}, Role: {sw['role']})")
        
        print("\nConnections:")
        for conn in topo["connections"]:
            print(f"  - {conn['from']} <-> {conn['to']}")
